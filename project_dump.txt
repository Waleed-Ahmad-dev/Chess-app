File: ./cmd/chess/main.go
----------------
package main

import (
	"bufio"
	"fmt"
	"os"
	"os/exec"
	"runtime"
	"strings"

	"github.com/Waleed-Ahmad-dev/Chess-app/internal/game"
	"github.com/Waleed-Ahmad-dev/Chess-app/internal/server"
	"github.com/Waleed-Ahmad-dev/Chess-app/internal/sound"
)

func main() {
	// Check if user wants web mode
	if len(os.Args) > 1 && os.Args[1] == "web" {
		fmt.Println("Starting Chess Web Server...")
		fmt.Println("Open your browser and go to: http://localhost:8080")
		server.StartServer()
		return
	}

	// Check for sound disable flag
	soundEnabled := true
	for _, arg := range os.Args[1:] {
		if arg == "--no-sound" || arg == "-n" {
			soundEnabled = false
			break
		}
	}

	if soundEnabled {
		sound.EnableSound()
	} else {
		sound.DisableSound()
		fmt.Println("Sound disabled. Use --no-sound or -n to disable sound.")
	}

	// Original CLI mode
	gameInstance := game.NewGame()
	reader := bufio.NewReader(os.Stdin)

	// --- The Game Loop ---
	for {
		clearScreen()
		gameInstance.Board.Draw()

		// 1. Generate Legal Moves for the current turn
		legalMoves := gameInstance.GenerateLegalMoves()

		// 2. Check Game Over Conditions
		if len(legalMoves) == 0 {
			if gameInstance.Board.InCheck(gameInstance.Turn) {
				fmt.Printf("\nCheckmate! %s wins!\n", getOpponentColor(gameInstance.Turn))
				if soundEnabled {
					sound.PlaySound(sound.SoundCheckmate)
				}
			} else {
				fmt.Println("\nStalemate! The game is a draw.")
			}
			break
		}

		// 3. Print Status
		if gameInstance.Board.InCheck(gameInstance.Turn) {
			fmt.Println("\n⚠️  CHECK! ⚠️")
		}
		fmt.Printf("\n%s's turn to move.\n", gameInstance.Turn)
		fmt.Print("Enter move (e.g., 'e2e4'): ")

		// 4. Read Input
		input, _ := reader.ReadString('\n')
		input = strings.TrimSpace(input)

		if input == "exit" || input == "quit" {
			fmt.Println("Goodbye!")
			break
		}

		// 5. Parse & Validate Move
		move, err := game.ParseMove(input, legalMoves)
		if err != nil {
			fmt.Printf("Error: %v\nPress Enter to try again...", err)
			if soundEnabled {
				sound.PlaySound(sound.SoundIllegal)
			}
			reader.ReadString('\n') // Wait for user to read error
			continue
		}

		// 6. Execute Move
		result := gameInstance.MakeMove(move)

		// 7. Play appropriate sound
		if soundEnabled {
			playMoveSound(result)
		}
	}
}

// Helper to clear the terminal screen
func clearScreen() {
	// Standard ANSI escape code to clear screen
	fmt.Print("\033[H\033[2J")

	// Fallback for Windows
	if runtime.GOOS == "windows" {
		cmd := exec.Command("cmd", "/c", "cls")
		cmd.Stdout = os.Stdout
		cmd.Run()
	}
}

func getOpponentColor(c game.Color) string {
	if c == game.White {
		return "Black"
	}
	return "White"
}

// playMoveSound plays the appropriate sound for a move
func playMoveSound(result game.MoveResult) {
	if result.WasCheckmate {
		sound.PlaySound(sound.SoundCheckmate)
		return
	}

	if result.WasCheck {
		sound.PlaySound(sound.SoundCheck)
		return
	}

	if result.WasCastle {
		sound.PlaySound(sound.SoundCastle)
		return
	}

	if result.WasPromotion {
		sound.PlaySound(sound.SoundPromote)
		return
	}

	if result.WasCapture {
		sound.PlaySound(sound.SoundCapture)
		return
	}

	// Default move sound
	sound.PlaySound(sound.SoundMove)
}



File: ./internal/sound/sound.go
----------------
package sound

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
)

// SoundType represents different chess sounds
type SoundType int

const (
	SoundMove SoundType = iota
	SoundCapture
	SoundCastle
	SoundCheck
	SoundCheckmate
	SoundIllegal
	SoundPromote
)

var (
	soundEnabled = true
	assetPath    = "internal/server/assets"
)

// EnableSound enables sound playback
func EnableSound() {
	soundEnabled = true
}

// DisableSound disables sound playback
func DisableSound() {
	soundEnabled = false
}

// SetAssetPath sets the custom path for sound assets
func SetAssetPath(path string) {
	assetPath = path
}

// PlaySound plays a specific chess sound
func PlaySound(soundType SoundType) error {
	if !soundEnabled {
		return nil
	}

	var soundFile string
	switch soundType {
	case SoundMove:
		soundFile = "move.mp3"
	case SoundCapture:
		soundFile = "capture.mp3"
	case SoundCastle:
		soundFile = "castle.mp3"
	case SoundCheck:
		soundFile = "check.mp3"
	case SoundCheckmate:
		soundFile = "checkmate.mp3"
	case SoundIllegal:
		soundFile = "illegal.mp3"
	case SoundPromote:
		soundFile = "promote.mp3"
	default:
		return fmt.Errorf("unknown sound type")
	}

	// Get the absolute path to the sound file
	exePath, err := os.Executable()
	if err != nil {
		// Fallback to relative path
		exePath = "."
	}
	exeDir := filepath.Dir(exePath)
	soundPath := filepath.Join(exeDir, assetPath, soundFile)

	// Check if file exists
	if _, err := os.Stat(soundPath); os.IsNotExist(err) {
		// Try relative to current directory
		soundPath = filepath.Join(assetPath, soundFile)
	}

	// Play sound based on OS
	return playSystemSound(soundPath)
}

// playSystemSound plays a sound file using system commands
func playSystemSound(soundPath string) error {
	if _, err := os.Stat(soundPath); os.IsNotExist(err) {
		return fmt.Errorf("sound file not found: %s", soundPath)
	}

	switch runtime.GOOS {
	case "darwin": // macOS
		cmd := exec.Command("afplay", soundPath)
		return cmd.Run()
	case "linux":
		// Try various Linux audio players
		players := []string{"aplay", "mpg123", "mpg321", "ffplay", "paplay"}
		for _, player := range players {
			if _, err := exec.LookPath(player); err == nil {
				args := []string{soundPath}
				if player == "ffplay" {
					args = []string{"-nodisp", "-autoexit", soundPath}
				}
				cmd := exec.Command(player, args...)
				return cmd.Run()
			}
		}
		return fmt.Errorf("no compatible audio player found on Linux")
	case "windows":
		cmd := exec.Command("powershell", "-c",
			fmt.Sprintf("(New-Object Media.SoundPlayer '%s').PlaySync()", soundPath))
		return cmd.Run()
	default:
		return fmt.Errorf("unsupported operating system: %s", runtime.GOOS)
	}
}



File: ./internal/sound/web_sound.go
----------------
package sound

// WebSoundManager handles sound for web version
type WebSoundManager struct {
	sounds map[SoundType]string
}

// NewWebSoundManager creates a new web sound manager
func NewWebSoundManager() *WebSoundManager {
	return &WebSoundManager{
		sounds: map[SoundType]string{
			SoundMove:      "/move.mp3",
			SoundCapture:   "/capture.mp3",
			SoundCastle:    "/castle.mp3",
			SoundCheck:     "/check.mp3",
			SoundCheckmate: "/checkmate.mp3",
			SoundIllegal:   "/illegal.mp3",
			SoundPromote:   "/promote.mp3",
		},
	}
}

// GetSoundURL returns the URL for a sound type
func (w *WebSoundManager) GetSoundURL(soundType SoundType) string {
	if url, ok := w.sounds[soundType]; ok {
		return url
	}
	return ""
}

// GetAllSoundURLs returns all sound URLs
func (w *WebSoundManager) GetAllSoundURLs() map[SoundType]string {
	return w.sounds
}



File: ./internal/game/input.go
----------------
package game

import (
	"fmt"
	"strings"
)

// ParseMove takes a UCI string (e.g., "e2e4" or "a7a8q") and a list of legal moves.
// It returns the matching Move struct if found, and a boolean indicating success.
func ParseMove(input string, legalMoves []Move) (Move, error) {
	cleanInput := strings.TrimSpace(input)

	// Basic validation: UCI moves are 4 or 5 chars (e.g., "e2e4", "e7e8q")
	if len(cleanInput) < 4 || len(cleanInput) > 5 {
		return Move{}, fmt.Errorf("invalid format. Use UCI format like 'e2e4' or 'a7a8q'")
	}

	fromStr := cleanInput[:2]
	toStr := cleanInput[2:4]

	fromIdx := CoordToIndex(fromStr)
	toIdx := CoordToIndex(toStr)

	if fromIdx == -1 || toIdx == -1 {
		return Move{}, fmt.Errorf("invalid coordinates")
	}

	// --- 1. Standard Move Matching ---
	var candidates []Move
	for _, m := range legalMoves {
		if m.From == fromIdx && m.To == toIdx {
			candidates = append(candidates, m)
		}
	}

	// --- 2. Special Castling Handling (King -> Rook) ---
	// If no standard move found, check if user tried to castle by clicking King then Rook
	if len(candidates) == 0 {
		candidates = checkAlternativeCastling(fromIdx, toIdx, legalMoves)
	}

	if len(candidates) == 0 {
		return Move{}, fmt.Errorf("illegal move")
	}

	// If only one candidate, it's a standard move (or unique move)
	if len(candidates) == 1 {
		return candidates[0], nil
	}

	// If multiple candidates, it must be a promotion (Q, R, B, N available)
	// We need the 5th character to distinguish.
	if len(cleanInput) != 5 {
		return Move{}, fmt.Errorf("promotion detected. Please specify piece (q, r, b, n). Example: %sq", cleanInput)
	}

	promotionChar := rune(cleanInput[4])
	var targetType PieceType

	switch strings.ToLower(string(promotionChar)) {
	case "q":
		targetType = Queen
	case "r":
		targetType = Rook
	case "b":
		targetType = Bishop
	case "n":
		targetType = Knight
	default:
		return Move{}, fmt.Errorf("invalid promotion piece '%c'. Use q, r, b, or n", promotionChar)
	}

	// Find the specific promotion move
	for _, m := range candidates {
		if m.Promotion == targetType {
			return m, nil
		}
	}

	return Move{}, fmt.Errorf("could not match promotion move")
}

// checkAlternativeCastling allows castling by clicking King -> Rook (e.g. e1h1 -> e1g1)
func checkAlternativeCastling(from, to int, legalMoves []Move) []Move {
	// Map of King->Rook moves to their actual King->Dest moves
	// Key: KingFrom * 100 + RookTo, Value: Actual KingTo
	castlingMap := map[int]int{
		6063: 62, // White Short (e1->h1 implies e1->g1)
		6056: 58, // White Long  (e1->a1 implies e1->c1)
		407:  6,  // Black Short (e8->h8 implies e8->g8)
		400:  2,  // Black Long  (e8->a8 implies e8->c8)
	}

	key := from*100 + to
	targetSq, exists := castlingMap[key]

	if !exists {
		return nil
	}

	// Check if the actual castling move exists in legal moves
	var result []Move
	for _, m := range legalMoves {
		if m.From == from && m.To == targetSq && m.MoveType == MoveCastling {
			result = append(result, m)
		}
	}
	return result
}



File: ./internal/game/fen.go
----------------
package game

import (
	"strings"
	"unicode"
)

// LoadFEN parses a FEN string and updates the Game state
func (g *Game) LoadFEN(fen string) {
	parts := strings.Split(fen, " ")

	// 1. Piece Placement
	piecePlacement := parts[0]
	g.Board = Board{} // Clear board

	rank := 7
	file := 0

	for _, char := range piecePlacement {
		if char == '/' {
			rank--
			file = 0
			continue
		}

		if unicode.IsDigit(char) {
			emptyCount := int(char - '0')
			file += emptyCount
		} else {
			index := rank*8 + file
			g.Board[index] = charToPiece(char)
			file++
		}
	}

	// 2. Turn
	if len(parts) > 1 {
		if parts[1] == "w" {
			g.Turn = White
		} else {
			g.Turn = Black
		}
	}

	// 3. Castling Rights
	// Default to false, then enable based on string
	g.Castling = CastlingRights{}
	if len(parts) > 2 {
		c := parts[2]
		if c != "-" {
			for _, char := range c {
				switch char {
				case 'K':
					g.Castling.WhiteKingSide = true
				case 'Q':
					g.Castling.WhiteQueenSide = true
				case 'k':
					g.Castling.BlackKingSide = true
				case 'q':
					g.Castling.BlackQueenSide = true
				}
			}
		}
	}

	// 4. En Passant
	g.EnPassantTarget = -1
	if len(parts) > 3 {
		ep := parts[3]
		if ep != "-" {
			g.EnPassantTarget = CoordToIndex(ep)
		}
	}
}

func charToPiece(char rune) Piece {
	switch char {
	case 'P':
		return Piece{Type: Pawn, Color: White}
	case 'N':
		return Piece{Type: Knight, Color: White}
	case 'B':
		return Piece{Type: Bishop, Color: White}
	case 'R':
		return Piece{Type: Rook, Color: White}
	case 'Q':
		return Piece{Type: Queen, Color: White}
	case 'K':
		return Piece{Type: King, Color: White}
	case 'p':
		return Piece{Type: Pawn, Color: Black}
	case 'n':
		return Piece{Type: Knight, Color: Black}
	case 'b':
		return Piece{Type: Bishop, Color: Black}
	case 'r':
		return Piece{Type: Rook, Color: Black}
	case 'q':
		return Piece{Type: Queen, Color: Black}
	case 'k':
		return Piece{Type: King, Color: Black}
	}
	return Piece{Type: Empty}
}



File: ./internal/game/helpers.go
----------------
package game

import "fmt"

// IndexToCoord converts 0 -> "a1", 63 -> "h8"
func IndexToCoord(index int) string {
	rank := index / 8
	file := index % 8
	// 'a' is ASCII 97, '1' is ASCII 49
	return fmt.Sprintf("%c%d", 'a'+file, rank+1)
}

// CoordToIndex converts "a1" -> 0
func CoordToIndex(coord string) int {
	if len(coord) != 2 {
		return -1
	}
	file := int(coord[0] - 'a')
	rank := int(coord[1] - '1')
	return rank*8 + file
}

// IsOnBoard checks if a square is valid (0-63)
func IsOnBoard(sq int) bool {
	return sq >= 0 && sq < 64
}



File: ./internal/game/move_test.go
----------------
package game

import (
	"testing"
)

// Test that kings cannot be captured
func TestKingCannotBeCaptured(t *testing.T) {
	g := NewGame()

	// Set up a scenario where a pawn could "capture" the king
	g.Board = Board{}
	g.Board[20] = Piece{Type: Pawn, Color: White} // e3
	g.Board[11] = Piece{Type: King, Color: Black} // d2
	g.Board[60] = Piece{Type: King, Color: White} // e1
	g.Turn = White

	legalMoves := g.GenerateLegalMoves()

	// Check that pawn cannot capture the king
	for _, m := range legalMoves {
		if m.From == 20 && m.To == 11 {
			t.Error("Pawn should not be able to capture the king!")
		}
	}
}

// Test basic castling
func TestCastling(t *testing.T) {
	g := NewGame()

	// Set up castling position for white
	g.Board = Board{}
	g.Board[60] = Piece{Type: King, Color: White} // e1
	g.Board[63] = Piece{Type: Rook, Color: White} // h1
	g.Board[56] = Piece{Type: Rook, Color: White} // a1
	g.Board[4] = Piece{Type: King, Color: Black}  // e8
	g.Board[7] = Piece{Type: Rook, Color: Black}  // h8
	g.Board[0] = Piece{Type: Rook, Color: Black}  // a8

	g.Turn = White
	g.Castling = CastlingRights{
		WhiteKingSide:  true,
		WhiteQueenSide: true,
		BlackKingSide:  true,
		BlackQueenSide: true,
	}

	legalMoves := g.GenerateLegalMoves()

	// Check for kingside castling
	foundKingside := false
	foundQueenside := false

	for _, m := range legalMoves {
		if m.From == 60 && m.To == 62 && m.MoveType == MoveCastling {
			foundKingside = true
		}
		if m.From == 60 && m.To == 58 && m.MoveType == MoveCastling {
			foundQueenside = true
		}
	}

	if !foundKingside {
		t.Error("White should be able to castle kingside")
	}
	if !foundQueenside {
		t.Error("White should be able to castle queenside")
	}
}

// Test that you cannot castle through check
func TestCannotCastleThroughCheck(t *testing.T) {
	g := NewGame()

	g.Board = Board{}
	g.Board[60] = Piece{Type: King, Color: White} // e1
	g.Board[63] = Piece{Type: Rook, Color: White} // h1
	g.Board[13] = Piece{Type: Rook, Color: Black} // f2 - attacks f1
	g.Board[4] = Piece{Type: King, Color: Black}  // e8

	g.Turn = White
	g.Castling.WhiteKingSide = true

	legalMoves := g.GenerateLegalMoves()

	// Should not be able to castle through f1
	for _, m := range legalMoves {
		if m.From == 60 && m.To == 62 && m.MoveType == MoveCastling {
			t.Error("Should not be able to castle through check (f1 is attacked)")
		}
	}
}

// Test that you cannot castle out of check
func TestCannotCastleOutOfCheck(t *testing.T) {
	g := NewGame()

	g.Board = Board{}
	g.Board[60] = Piece{Type: King, Color: White} // e1
	g.Board[63] = Piece{Type: Rook, Color: White} // h1
	g.Board[12] = Piece{Type: Rook, Color: Black} // e2 - checks king on e1
	g.Board[4] = Piece{Type: King, Color: Black}  // e8

	g.Turn = White
	g.Castling.WhiteKingSide = true

	legalMoves := g.GenerateLegalMoves()

	// Should not be able to castle when in check
	for _, m := range legalMoves {
		if m.MoveType == MoveCastling {
			t.Error("Should not be able to castle when in check")
		}
	}
}

// Test en passant capture
func TestEnPassant(t *testing.T) {
	g := NewGame()

	// Set up en passant scenario
	g.Board = Board{}
	g.Board[35] = Piece{Type: Pawn, Color: White} // d5
	g.Board[36] = Piece{Type: Pawn, Color: Black} // e5 (just moved from e7)
	g.Board[60] = Piece{Type: King, Color: White} // e1
	g.Board[4] = Piece{Type: King, Color: Black}  // e8

	g.Turn = White
	g.EnPassantTarget = 28 // e6 - the square behind the black pawn

	legalMoves := g.GenerateLegalMoves()

	foundEnPassant := false
	for _, m := range legalMoves {
		if m.From == 35 && m.To == 28 && m.MoveType == MoveEnPassant {
			foundEnPassant = true
		}
	}

	if !foundEnPassant {
		t.Error("En passant capture should be possible")
	}

	// Execute the en passant move
	for _, m := range legalMoves {
		if m.From == 35 && m.To == 28 && m.MoveType == MoveEnPassant {
			g.MakeMove(m)
			break
		}
	}

	// Check that the captured pawn is gone
	if g.Board[36].Type != Empty {
		t.Error("Captured pawn should be removed from e5")
	}

	// Check that the capturing pawn is in the right place
	if g.Board[28].Type != Pawn || g.Board[28].Color != White {
		t.Error("White pawn should be on e6")
	}
}

// Test pawn promotion
func TestPawnPromotion(t *testing.T) {
	g := NewGame()

	g.Board = Board{}
	g.Board[54] = Piece{Type: Pawn, Color: White} // g7
	g.Board[60] = Piece{Type: King, Color: White} // e1
	g.Board[4] = Piece{Type: King, Color: Black}  // e8

	g.Turn = White

	legalMoves := g.GenerateLegalMoves()

	// Should have 4 promotion options
	promotionMoves := 0
	for _, m := range legalMoves {
		if m.From == 54 && m.To == 62 && m.Promotion != Empty {
			promotionMoves++
		}
	}

	if promotionMoves != 4 {
		t.Errorf("Expected 4 promotion moves, got %d", promotionMoves)
	}
}

// Test that pieces cannot move through other pieces
func TestPiecesCannotMoveThroughOthers(t *testing.T) {
	g := NewGame()

	g.Board = Board{}
	g.Board[0] = Piece{Type: Rook, Color: White}  // a1
	g.Board[1] = Piece{Type: Pawn, Color: White}  // b1
	g.Board[60] = Piece{Type: King, Color: White} // e1
	g.Board[4] = Piece{Type: King, Color: Black}  // e8

	g.Turn = White

	legalMoves := g.GenerateLegalMoves()

	// Rook should not be able to move past the pawn
	for _, m := range legalMoves {
		if m.From == 0 && (m.To == 2 || m.To == 3 || m.To == 4 || m.To == 5 || m.To == 6 || m.To == 7) {
			t.Errorf("Rook should not be able to move through pawn to %s", IndexToCoord(m.To))
		}
	}
}

// Test checkmate detection
func TestCheckmateDetection(t *testing.T) {
	g := NewGame()

	// Back rank mate
	g.Board = Board{}
	g.Board[7] = Piece{Type: King, Color: Black}  // h8
	g.Board[6] = Piece{Type: Pawn, Color: Black}  // g8
	g.Board[15] = Piece{Type: Pawn, Color: Black} // h7
	g.Board[14] = Piece{Type: Pawn, Color: Black} // g7
	g.Board[23] = Piece{Type: Rook, Color: White} // h6 - delivers checkmate
	g.Board[60] = Piece{Type: King, Color: White} // e1

	g.Turn = Black

	legalMoves := g.GenerateLegalMoves()

	if len(legalMoves) != 0 {
		t.Error("Should have no legal moves (checkmate)")
	}

	if !g.Board.InCheck(Black) {
		t.Error("Black king should be in check")
	}
}

// Test stalemate detection
func TestStalemateDetection(t *testing.T) {
	g := NewGame()

	// King + pawn vs king stalemate
	g.Board = Board{}
	g.Board[0] = Piece{Type: King, Color: Black}   // a1
	g.Board[9] = Piece{Type: King, Color: White}   // b2
	g.Board[16] = Piece{Type: Queen, Color: White} // a3

	g.Turn = Black

	legalMoves := g.GenerateLegalMoves()

	if len(legalMoves) != 0 {
		t.Error("Should have no legal moves (stalemate)")
	}

	if g.Board.InCheck(Black) {
		t.Error("Black king should NOT be in check (stalemate, not checkmate)")
	}
}

// Test castling rights are lost after king moves
func TestCastlingRightsLostAfterKingMove(t *testing.T) {
	g := NewGame()

	g.Board = Board{}
	g.Board[60] = Piece{Type: King, Color: White} // e1
	g.Board[63] = Piece{Type: Rook, Color: White} // h1
	g.Board[4] = Piece{Type: King, Color: Black}  // e8

	g.Turn = White
	g.Castling.WhiteKingSide = true

	// Move king
	move := Move{From: 60, To: 61, Piece: King}
	g.MakeMove(move)

	if g.Castling.WhiteKingSide {
		t.Error("White should lose kingside castling rights after king moves")
	}
}

// Test castling rights are lost after rook moves
func TestCastlingRightsLostAfterRookMove(t *testing.T) {
	g := NewGame()

	g.Board = Board{}
	g.Board[60] = Piece{Type: King, Color: White} // e1
	g.Board[63] = Piece{Type: Rook, Color: White} // h1
	g.Board[4] = Piece{Type: King, Color: Black}  // e8

	g.Turn = White
	g.Castling.WhiteKingSide = true

	// Move rook
	move := Move{From: 63, To: 62, Piece: Rook}
	g.MakeMove(move)

	if g.Castling.WhiteKingSide {
		t.Error("White should lose kingside castling rights after h1 rook moves")
	}
}

// Test that king cannot move into check
func TestKingCannotMoveIntoCheck(t *testing.T) {
	g := NewGame()

	g.Board = Board{}
	g.Board[60] = Piece{Type: King, Color: White} // e1
	g.Board[13] = Piece{Type: Rook, Color: Black} // f2 - controls f1
	g.Board[4] = Piece{Type: King, Color: Black}  // e8

	g.Turn = White

	legalMoves := g.GenerateLegalMoves()

	// King should not be able to move to f1
	for _, m := range legalMoves {
		if m.From == 60 && m.To == 61 {
			t.Error("King should not be able to move into check (f1)")
		}
	}
}



File: ./internal/game/state.go
----------------
package game

// MakeMove executes a move on the board and updates game state
func (g *Game) MakeMove(m Move) MoveResult {
	// --- Capture State Snapshot ---
	var lastMove Move
	if len(g.History) > 0 {
		lastMove = g.History[len(g.History)-1]
	}

	snapshot := StateSnapshot{
		Board:           g.Board,
		Castling:        g.Castling,
		EnPassantTarget: g.EnPassantTarget,
		Turn:            g.Turn,
		LastMove:        lastMove,
	}
	g.StateHistory = append(g.StateHistory, snapshot)
	// ----------------------------------------

	// Store original pieces for sound detection
	targetPiece := g.Board[m.To]

	wasCapture := targetPiece.Type != Empty
	wasCastle := m.MoveType == MoveCastling
	wasPromotion := m.Promotion != Empty

	// Execute the move (existing code remains the same)
	capturedPiece := g.Board[m.To]
	movingPiece := g.Board[m.From]
	g.Board[m.From] = Piece{Type: Empty}

	if m.Promotion != Empty {
		movingPiece.Type = m.Promotion
	}
	g.Board[m.To] = movingPiece

	// --- Special Move Logic ---
	if m.MoveType == MoveEnPassant {
		var captureSq int
		if g.Turn == White {
			captureSq = m.To - 8
		} else {
			captureSq = m.To + 8
		}
		g.Board[captureSq] = Piece{Type: Empty}
		wasCapture = true
	}

	if m.MoveType == MoveCastling {
		switch m.To {
		case 62:
			rook := g.Board[63]
			g.Board[63] = Piece{Type: Empty}
			g.Board[61] = rook
		case 58:
			rook := g.Board[56]
			g.Board[56] = Piece{Type: Empty}
			g.Board[59] = rook
		case 6:
			rook := g.Board[7]
			g.Board[7] = Piece{Type: Empty}
			g.Board[5] = rook
		case 2:
			rook := g.Board[0]
			g.Board[0] = Piece{Type: Empty}
			g.Board[3] = rook
		}
	}

	// Update game state
	g.EnPassantTarget = -1
	if movingPiece.Type == Pawn {
		diff := m.To - m.From
		if diff == 16 || diff == -16 {
			g.EnPassantTarget = m.From + (diff / 2)
		}
	}

	// Update Castling Rights
	if movingPiece.Type == King {
		if g.Turn == White {
			g.Castling.WhiteKingSide = false
			g.Castling.WhiteQueenSide = false
		} else {
			g.Castling.BlackKingSide = false
			g.Castling.BlackQueenSide = false
		}
	}

	if movingPiece.Type == Rook {
		if m.From == 63 {
			g.Castling.WhiteKingSide = false
		}
		if m.From == 56 {
			g.Castling.WhiteQueenSide = false
		}
		if m.From == 7 {
			g.Castling.BlackKingSide = false
		}
		if m.From == 0 {
			g.Castling.BlackQueenSide = false
		}
	}

	if capturedPiece.Type == Rook {
		switch m.To {
		case 63:
			g.Castling.WhiteKingSide = false
		case 56:
			g.Castling.WhiteQueenSide = false
		case 7:
			g.Castling.BlackKingSide = false
		case 0:
			g.Castling.BlackQueenSide = false
		}
	}

	// Record history
	g.History = append(g.History, m)

	// Check for check/checkmate after move
	opponentColor := Black
	if g.Turn == Black {
		opponentColor = White
	}

	wasCheck := g.Board.InCheck(opponentColor)
	wasCheckmate := false

	if wasCheck {
		// Generate opponent's moves to check if it's checkmate
		tempGame := &Game{
			Board:           g.Board,
			Turn:            opponentColor,
			Castling:        g.Castling,
			EnPassantTarget: g.EnPassantTarget,
		}
		opponentMoves := tempGame.GenerateLegalMoves()
		wasCheckmate = len(opponentMoves) == 0
	}

	// Create move result
	result := MoveResult{
		Move:         m,
		WasCapture:   wasCapture,
		WasCheck:     wasCheck,
		WasCheckmate: wasCheckmate,
		WasCastle:    wasCastle,
		WasPromotion: wasPromotion,
		WasIllegal:   false,
	}

	g.MoveResults = append(g.MoveResults, result)

	// Switch turn
	if g.Turn == White {
		g.Turn = Black
	} else {
		g.Turn = White
	}

	return result
}

// UndoMove reverts the last move using the StateStack
func (g *Game) UndoMove() {
	// 1. Check if StateHistory is empty
	if len(g.StateHistory) == 0 {
		return
	}

	// 2. Pop the last snapshot
	lastIndex := len(g.StateHistory) - 1
	snapshot := g.StateHistory[lastIndex]

	// 3. Overwrite game state with values from the snapshot
	g.Board = snapshot.Board
	g.Castling = snapshot.Castling
	g.EnPassantTarget = snapshot.EnPassantTarget
	g.Turn = snapshot.Turn

	// 4. Remove the snapshot from the list
	g.StateHistory = g.StateHistory[:lastIndex]

	// 5. Sync the Move History
	// Since the snapshot was taken *before* the move was made,
	// the move currently at the end of g.History is the one we just undid.
	// We must remove it to keep the history in sync with the board.
	if len(g.History) > 0 {
		g.History = g.History[:len(g.History)-1]
	}
}

// GetLastMoveResult returns the last move result
func (g *Game) GetLastMoveResult() *MoveResult {
	if len(g.MoveResults) == 0 {
		return nil
	}
	return &g.MoveResults[len(g.MoveResults)-1]
}



File: ./internal/game/moves.go
----------------
package game

func (g *Game) GenerateLegalMoves() []Move {
	pseudoMoves := g.GeneratePseudoLegalMoves()
	legalMoves := []Move{}

	for _, m := range pseudoMoves {
		if g.isMoveLegal(m) {
			legalMoves = append(legalMoves, m)
		}
	}

	return legalMoves
}

// isMoveLegal checks if a move is legal by simulating it and checking if king is safe
func (g *Game) isMoveLegal(m Move) bool {
	// Create a temporary board copy
	tempBoard := g.Board

	// Store original en passant target for restoration
	originalEP := g.EnPassantTarget

	// Execute move on temp board
	tempBoard[m.To] = tempBoard[m.From]
	tempBoard[m.From] = Piece{Type: Empty}

	if m.Promotion != Empty {
		tempBoard[m.To] = Piece{Type: m.Promotion, Color: g.Turn}
	}

	// Handle En Passant Capture
	if m.MoveType == MoveEnPassant {
		var captureSq int
		if g.Turn == White {
			captureSq = m.To - 8
		} else {
			captureSq = m.To + 8
		}
		tempBoard[captureSq] = Piece{Type: Empty}
	}

	// Handle Castling Rook Move
	if m.MoveType == MoveCastling {
		switch m.To {
		case 62: // White Short
			tempBoard[61] = tempBoard[63]
			tempBoard[63] = Piece{Type: Empty}
		case 58: // White Long
			tempBoard[59] = tempBoard[56]
			tempBoard[56] = Piece{Type: Empty}
		case 6: // Black Short
			tempBoard[5] = tempBoard[7]
			tempBoard[7] = Piece{Type: Empty}
		case 2: // Black Long
			tempBoard[3] = tempBoard[0]
			tempBoard[0] = Piece{Type: Empty}
		}
	}

	// Verify King Safety
	isLegal := !tempBoard.InCheck(g.Turn)

	// Restore en passant target
	g.EnPassantTarget = originalEP

	return isLegal
}

func (g *Game) GeneratePseudoLegalMoves() []Move {
	moves := []Move{}
	turn := g.Turn
	b := g.Board

	for sq := 0; sq < 64; sq++ {
		piece := b[sq]

		if piece.Type == Empty || piece.Color != turn {
			continue
		}

		switch piece.Type {
		case Pawn:
			moves = append(moves, g.getPawnMoves(sq)...)
		case Knight:
			moves = append(moves, b.getKnightMoves(sq)...)
		case Bishop, Rook, Queen:
			moves = append(moves, b.getSlidingMoves(sq)...)
		case King:
			moves = append(moves, g.getKingMoves(sq)...)
		}
	}
	return moves
}

// --- Stepping Pieces (Knight, King) ---

func (b *Board) getKnightMoves(sq int) []Move {
	moves := []Move{}
	offsets := [][2]int{
		{1, 2}, {1, -2}, {-1, 2}, {-1, -2},
		{2, 1}, {2, -1}, {-2, 1}, {-2, -1},
	}
	b.addSteppingMoves(sq, offsets, &moves)
	return moves
}

func (g *Game) getKingMoves(sq int) []Move {
	moves := []Move{}
	b := g.Board

	// 1. Normal King Moves
	offsets := [][2]int{
		{0, 1}, {0, -1}, {1, 0}, {-1, 0},
		{1, 1}, {1, -1}, {-1, 1}, {-1, -1},
	}
	b.addSteppingMoves(sq, offsets, &moves)

	// 2. Castling - only add if not in check
	if b.InCheck(g.Turn) {
		return moves
	}

	if g.Turn == White {
		// White Short Castling (e1 -> g1)
		if g.Castling.WhiteKingSide && sq == 60 { // King must be on e1
			if b[61].Type == Empty && b[62].Type == Empty && // f1 and g1 empty
				b[63].Type == Rook && b[63].Color == White { // Rook on h1
				// Check that f1 and g1 are not attacked
				if !b.IsSquareAttacked(61, Black) && !b.IsSquareAttacked(62, Black) {
					moves = append(moves, Move{From: sq, To: 62, Piece: King, MoveType: MoveCastling})
				}
			}
		}

		// White Long Castling (e1 -> c1)
		if g.Castling.WhiteQueenSide && sq == 60 { // King must be on e1
			if b[59].Type == Empty && b[58].Type == Empty && b[57].Type == Empty && // d1, c1, b1 empty
				b[56].Type == Rook && b[56].Color == White { // Rook on a1
				// Check that d1 and c1 are not attacked (b1 doesn't matter)
				if !b.IsSquareAttacked(59, Black) && !b.IsSquareAttacked(58, Black) {
					moves = append(moves, Move{From: sq, To: 58, Piece: King, MoveType: MoveCastling})
				}
			}
		}
	} else {
		// Black Short Castling (e8 -> g8)
		if g.Castling.BlackKingSide && sq == 4 { // King must be on e8
			if b[5].Type == Empty && b[6].Type == Empty && // f8 and g8 empty
				b[7].Type == Rook && b[7].Color == Black { // Rook on h8
				// Check that f8 and g8 are not attacked
				if !b.IsSquareAttacked(5, White) && !b.IsSquareAttacked(6, White) {
					moves = append(moves, Move{From: sq, To: 6, Piece: King, MoveType: MoveCastling})
				}
			}
		}

		// Black Long Castling (e8 -> c8)
		if g.Castling.BlackQueenSide && sq == 4 { // King must be on e8
			if b[3].Type == Empty && b[2].Type == Empty && b[1].Type == Empty && // d8, c8, b8 empty
				b[0].Type == Rook && b[0].Color == Black { // Rook on a8
				// Check that d8 and c8 are not attacked (b8 doesn't matter)
				if !b.IsSquareAttacked(3, White) && !b.IsSquareAttacked(2, White) {
					moves = append(moves, Move{From: sq, To: 2, Piece: King, MoveType: MoveCastling})
				}
			}
		}
	}

	return moves
}

func (b *Board) addSteppingMoves(sq int, offsets [][2]int, moves *[]Move) {
	startRank := sq / 8
	startFile := sq % 8
	movingPiece := b[sq]

	for _, off := range offsets {
		dFile, dRank := off[0], off[1]
		targetRank := startRank + dRank
		targetFile := startFile + dFile

		if targetRank >= 0 && targetRank < 8 && targetFile >= 0 && targetFile < 8 {
			targetSq := targetRank*8 + targetFile
			targetPiece := b[targetSq]

			// Can only move to empty square or capture opponent's piece (NOT own piece)
			if targetPiece.Type == Empty || targetPiece.Color != movingPiece.Color {
				*moves = append(*moves, Move{From: sq, To: targetSq, Piece: movingPiece.Type})
			}
		}
	}
}

// --- Sliding Pieces ---

func (b *Board) getSlidingMoves(sq int) []Move {
	moves := []Move{}
	piece := b[sq]
	var directions [][2]int

	if piece.Type == Bishop || piece.Type == Queen {
		directions = append(directions, [][2]int{{1, 1}, {1, -1}, {-1, 1}, {-1, -1}}...)
	}
	if piece.Type == Rook || piece.Type == Queen {
		directions = append(directions, [][2]int{{0, 1}, {0, -1}, {1, 0}, {-1, 0}}...)
	}

	startRank := sq / 8
	startFile := sq % 8

	for _, dir := range directions {
		dFile, dRank := dir[0], dir[1]
		for i := 1; i < 8; i++ {
			targetRank := startRank + (dRank * i)
			targetFile := startFile + (dFile * i)

			if targetRank < 0 || targetRank > 7 || targetFile < 0 || targetFile > 7 {
				break
			}

			targetSq := targetRank*8 + targetFile
			targetPiece := b[targetSq]

			if targetPiece.Type == Empty {
				moves = append(moves, Move{From: sq, To: targetSq, Piece: piece.Type})
			} else {
				// Can capture opponent's piece, but not own piece
				if targetPiece.Color != piece.Color {
					moves = append(moves, Move{From: sq, To: targetSq, Piece: piece.Type})
				}
				break // Blocked by any piece
			}
		}
	}
	return moves
}

// --- Pawns ---

func (g *Game) getPawnMoves(sq int) []Move {
	moves := []Move{}
	b := g.Board
	piece := b[sq]

	rank := sq / 8
	file := sq % 8

	direction := 1
	startRank := 1
	promotionRank := 7

	if piece.Color == Black {
		direction = -1
		startRank = 6
		promotionRank = 0
	}

	// 1. Forward Move
	targetRank := rank + direction
	if targetRank >= 0 && targetRank < 8 {
		targetSq := targetRank*8 + file
		if b[targetSq].Type == Empty {
			// Check for promotion
			if targetRank == promotionRank {
				promotions := []PieceType{Queen, Rook, Bishop, Knight}
				for _, p := range promotions {
					moves = append(moves, Move{From: sq, To: targetSq, Piece: Pawn, Promotion: p})
				}
			} else {
				moves = append(moves, Move{From: sq, To: targetSq, Piece: Pawn})
			}

			// 2. Double Move from starting position
			if rank == startRank {
				doubleRank := rank + (2 * direction)
				doubleSq := doubleRank*8 + file
				if b[doubleSq].Type == Empty {
					moves = append(moves, Move{From: sq, To: doubleSq, Piece: Pawn})
				}
			}
		}
	}

	// 3. Captures (Normal + En Passant)
	captureOffsets := []int{-1, 1}
	for _, off := range captureOffsets {
		captureFile := file + off
		if captureFile >= 0 && captureFile < 8 {
			targetRank := rank + direction
			if targetRank >= 0 && targetRank < 8 {
				targetSq := targetRank*8 + captureFile
				targetPiece := b[targetSq]

				// Normal Capture - must be opponent's piece
				if targetPiece.Type != Empty && targetPiece.Color != piece.Color {
					if targetRank == promotionRank {
						promotions := []PieceType{Queen, Rook, Bishop, Knight}
						for _, p := range promotions {
							moves = append(moves, Move{From: sq, To: targetSq, Piece: Pawn, Promotion: p})
						}
					} else {
						moves = append(moves, Move{From: sq, To: targetSq, Piece: Pawn})
					}
				}

				// En Passant Capture
				if targetPiece.Type == Empty && targetSq == g.EnPassantTarget {
					moves = append(moves, Move{From: sq, To: targetSq, Piece: Pawn, MoveType: MoveEnPassant})
				}
			}
		}
	}

	return moves
}



File: ./internal/game/board.go
----------------
package game

import "fmt"

const StartFEN = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1"

// Draw prints the board to the console
func (b *Board) Draw() {
	fmt.Println("\n   A B C D E F G H")
	fmt.Println("  -----------------")

	// Loop from Rank 8 (top) down to Rank 1 (bottom)
	for rank := 7; rank >= 0; rank-- {
		fmt.Printf("%d |", rank+1)
		for file := 0; file < 8; file++ {
			index := rank*8 + file
			piece := b[index]
			fmt.Printf(" %s", piece.String())
		}
		fmt.Printf(" | %d\n", rank+1)
	}
	fmt.Println("  -----------------")
	fmt.Println("   A B C D E F G H")
}



File: ./internal/game/checks.go
----------------
package game

// InCheck returns true if the King of the given color is under attack
func (b *Board) InCheck(color Color) bool {
	// 1. Find the King
	kingPos := -1
	for i := 0; i < 64; i++ {
		piece := b[i]
		if piece.Type == King && piece.Color == color {
			kingPos = i
			break
		}
	}

	// Should not happen in a valid game, but safeguard
	if kingPos == -1 {
		return false
	}

	// 2. Check if that square is attacked by the opponent
	enemyColor := Black
	if color == Black {
		enemyColor = White
	}

	return b.IsSquareAttacked(kingPos, enemyColor)
}

// IsSquareAttacked checks if 'sq' is attacked by pieces of 'attackerColor'
func (b *Board) IsSquareAttacked(sq int, attackerColor Color) bool {
	rank := sq / 8
	file := sq % 8

	// 1. Check for Pawn attacks
	pawnDir := -1
	if attackerColor == White {
		pawnDir = 1 // White pawns attack upward (from lower ranks)
	}

	checkRank := rank - pawnDir
	if checkRank >= 0 && checkRank < 8 {
		for _, fileOffset := range []int{-1, 1} {
			checkFile := file + fileOffset
			if checkFile >= 0 && checkFile < 8 {
				idx := checkRank*8 + checkFile
				target := b[idx]
				if target.Type == Pawn && target.Color == attackerColor {
					return true
				}
			}
		}
	}

	// 2. Check for Knight attacks
	knightMoves := [][2]int{
		{-2, -1}, {-2, 1}, {-1, -2}, {-1, 2},
		{1, -2}, {1, 2}, {2, -1}, {2, 1},
	}
	for _, move := range knightMoves {
		checkRank := rank + move[0]
		checkFile := file + move[1]
		if checkRank >= 0 && checkRank < 8 && checkFile >= 0 && checkFile < 8 {
			idx := checkRank*8 + checkFile
			target := b[idx]
			if target.Type == Knight && target.Color == attackerColor {
				return true
			}
		}
	}

	// 3. Check for Sliding attacks (Rook/Queen) - Orthogonal
	directions := [][2]int{{-1, 0}, {1, 0}, {0, -1}, {0, 1}}
	for _, dir := range directions {
		if b.checkSlidingAttack(sq, dir, attackerColor, true) {
			return true
		}
	}

	// 4. Check for Sliding attacks (Bishop/Queen) - Diagonal
	directions = [][2]int{{-1, -1}, {-1, 1}, {1, -1}, {1, 1}}
	for _, dir := range directions {
		if b.checkSlidingAttack(sq, dir, attackerColor, false) {
			return true
		}
	}

	// 5. Check for King attacks (1 square in all directions)
	kingMoves := [][2]int{
		{-1, -1}, {-1, 0}, {-1, 1},
		{0, -1}, {0, 1},
		{1, -1}, {1, 0}, {1, 1},
	}
	for _, move := range kingMoves {
		checkRank := rank + move[0]
		checkFile := file + move[1]
		if checkRank >= 0 && checkRank < 8 && checkFile >= 0 && checkFile < 8 {
			idx := checkRank*8 + checkFile
			target := b[idx]
			if target.Type == King && target.Color == attackerColor {
				return true
			}
		}
	}

	return false
}

// checkSlidingAttack checks for sliding piece attacks in a given direction
// isOrthogonal: true for rook-like moves, false for bishop-like moves
func (b *Board) checkSlidingAttack(startSq int, direction [2]int, attackerColor Color, isOrthogonal bool) bool {
	rank := startSq / 8
	file := startSq % 8

	dRank := direction[0]
	dFile := direction[1]

	for i := 1; i < 8; i++ {
		checkRank := rank + (dRank * i)
		checkFile := file + (dFile * i)

		// Out of bounds
		if checkRank < 0 || checkRank > 7 || checkFile < 0 || checkFile > 7 {
			break
		}

		idx := checkRank*8 + checkFile
		target := b[idx]

		// Empty square, continue sliding
		if target.Type == Empty {
			continue
		}

		// Found a piece
		if target.Color == attackerColor {
			// Check if it's the right type of attacker
			if isOrthogonal {
				// Orthogonal: Rook or Queen
				if target.Type == Rook || target.Type == Queen {
					return true
				}
			} else {
				// Diagonal: Bishop or Queen
				if target.Type == Bishop || target.Type == Queen {
					return true
				}
			}
		}

		// Blocked by any piece (same color or opponent)
		break
	}

	return false
}



File: ./internal/game/types.go
----------------
package game

// Color represents the side (White or Black)
type Color int

const (
	White Color = iota
	Black
)

func (c Color) String() string {
	if c == White {
		return "White"
	}
	return "Black"
}

// PieceType represents the rank of the piece
type PieceType int

const (
	Empty PieceType = iota
	Pawn
	Knight
	Bishop
	Rook
	Queen
	King
)

func (p PieceType) String() string {
	switch p {
	case Pawn:
		return "Pawn"
	case Knight:
		return "Knight"
	case Bishop:
		return "Bishop"
	case Rook:
		return "Rook"
	case Queen:
		return "Queen"
	case King:
		return "King"
	default:
		return "Empty"
	}
}

// Piece represents a piece on the board
type Piece struct {
	Type  PieceType
	Color Color
}

// Board represents the 8x8 chess board
type Board [64]Piece

// MoveType helps identify special moves
type MoveType int

const (
	MoveNormal MoveType = iota
	MoveCastling
	MoveEnPassant
)

// Move represents a single move
type Move struct {
	From      int
	To        int
	Piece     PieceType
	Promotion PieceType // If pawn promotion, what type?
	MoveType  MoveType  // Normal, Castling, or EnPassant
}

func (p Piece) String() string {
	if p.Type == Empty {
		return "."
	}
	switch p.Type {
	case Pawn:
		if p.Color == White {
			return "P"
		} else {
			return "p"
		}
	case Knight:
		if p.Color == White {
			return "N"
		} else {
			return "n"
		}
	case Bishop:
		if p.Color == White {
			return "B"
		} else {
			return "b"
		}
	case Rook:
		if p.Color == White {
			return "R"
		} else {
			return "r"
		}
	case Queen:
		if p.Color == White {
			return "Q"
		} else {
			return "q"
		}
	case King:
		if p.Color == White {
			return "K"
		} else {
			return "k"
		}
	}
	return "?"
}

// CastlingRights tracks permissions
type CastlingRights struct {
	WhiteKingSide  bool
	WhiteQueenSide bool
	BlackKingSide  bool
	BlackQueenSide bool
}

// StateSnapshot captures the game state before a move is made
type StateSnapshot struct {
	Board           Board
	Castling        CastlingRights
	EnPassantTarget int
	Turn            Color
	LastMove        Move
}

type Game struct {
	Board           Board
	Turn            Color
	History         []Move
	StateHistory    []StateSnapshot // Stack for Undo functionality
	Castling        CastlingRights
	EnPassantTarget int
	MoveResults     []MoveResult // Track move results for sound
}

// NewGame returns a game with the starting position
func NewGame() *Game {
	g := &Game{
		Turn:            White,
		History:         make([]Move, 0),
		StateHistory:    make([]StateSnapshot, 0),
		EnPassantTarget: -1,
		Castling:        CastlingRights{true, true, true, true},
	}
	g.LoadFEN(StartFEN)
	return g
}

// MoveResult contains information about the move outcome
type MoveResult struct {
	Move         Move
	WasCapture   bool
	WasCheck     bool
	WasCheckmate bool
	WasCastle    bool
	WasPromotion bool
	WasIllegal   bool
}



File: ./internal/server/server.go
----------------
package server

import (
	"embed"
	"encoding/json"
	"fmt"
	"io/fs"
	"log"
	"net/http"
	"sync"
	"time"

	"io"

	"github.com/Waleed-Ahmad-dev/Chess-app/internal/game"
	"github.com/Waleed-Ahmad-dev/Chess-app/internal/sound"
)

//go:embed assets
var assetsFS embed.FS

var (
	sessions     = make(map[string]*game.Game)
	sessionTimes = make(map[string]time.Time)
	mu           sync.RWMutex
	soundManager = sound.NewWebSoundManager()
)

type GameStateResponse struct {
	Board          []string `json:"board"`
	Turn           string   `json:"turn"`
	InCheck        bool     `json:"inCheck"`
	LegalMoves     []string `json:"legalMoves"`
	GameOver       bool     `json:"gameOver"`
	Winner         string   `json:"winner,omitempty"`
	IsStalemate    bool     `json:"isStalemate"`
	LastMove       string   `json:"lastMove,omitempty"`
	CapturedPieces []string `json:"capturedPieces"`
	SoundType      string   `json:"soundType,omitempty"` // Added for sound feedback
}

type MoveRequest struct {
	SessionID string `json:"sessionId"`
	Move      string `json:"move"`
}

type MoveResponse struct {
	Success bool              `json:"success"`
	Error   string            `json:"error,omitempty"`
	State   GameStateResponse `json:"state"`
}

// SoundData provides sound URLs to frontend
type SoundData struct {
	Move      string `json:"move"`
	Capture   string `json:"capture"`
	Castle    string `json:"castle"`
	Check     string `json:"check"`
	Checkmate string `json:"checkmate"`
	Illegal   string `json:"illegal"`
	Promote   string `json:"promote"`
}

func StartServer() {
	// Start cleanup goroutine
	go cleanupSessions()

	http.HandleFunc("/", serveHome)
	http.HandleFunc("/api/new-game", handleNewGame)
	http.HandleFunc("/api/game-state", handleGameState)
	http.HandleFunc("/api/make-move", handleMakeMove)
	http.HandleFunc("/api/undo-move", handleUndoMove)
	http.HandleFunc("/api/sounds", handleGetSounds) // New endpoint for sounds

	log.Println("Server starting on http://localhost:8080")
	log.Fatal(http.ListenAndServe(":8080", nil))
}

func serveHome(w http.ResponseWriter, r *http.Request) {
	assets, err := fs.Sub(assetsFS, "assets")
	if err != nil {
		log.Printf("Failed to sub-fs assets: %v", err)
		http.Error(w, "Internal Server Error", http.StatusInternalServerError)
		return
	}

	// Check if requesting an MP3 file
	if r.URL.Path == "/move.mp3" || r.URL.Path == "/capture.mp3" ||
		r.URL.Path == "/castle.mp3" || r.URL.Path == "/check.mp3" ||
		r.URL.Path == "/checkmate.mp3" || r.URL.Path == "/illegal.mp3" ||
		r.URL.Path == "/promote.mp3" {
		// Serve the specific sound file
		file, err := assets.Open(r.URL.Path[1:]) // Remove leading slash
		if err != nil {
			http.Error(w, "Sound not found", http.StatusNotFound)
			return
		}
		defer file.Close()

		w.Header().Set("Content-Type", "audio/mpeg")
		http.ServeContent(w, r, r.URL.Path, time.Now(), file.(io.ReadSeeker))
		return
	}

	http.FileServer(http.FS(assets)).ServeHTTP(w, r)
}

func handleNewGame(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	sessionID := generateSessionID()
	g := game.NewGame()

	mu.Lock()
	sessions[sessionID] = g
	sessionTimes[sessionID] = time.Now()
	mu.Unlock()

	response := map[string]interface{}{
		"sessionId": sessionID,
		"state":     getGameState(g, ""),
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(response)
}

func handleGameState(w http.ResponseWriter, r *http.Request) {
	sessionID := r.URL.Query().Get("sessionId")
	if sessionID == "" {
		http.Error(w, "Session ID required", http.StatusBadRequest)
		return
	}

	mu.RLock()
	g, exists := sessions[sessionID]
	mu.RUnlock()

	if !exists {
		http.Error(w, "Session not found", http.StatusNotFound)
		return
	}

	soundType := r.URL.Query().Get("soundType")

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(getGameState(g, soundType))
}

func handleMakeMove(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	var req MoveRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "Invalid request", http.StatusBadRequest)
		return
	}

	mu.RLock()
	g, exists := sessions[req.SessionID]
	mu.RUnlock()

	if !exists {
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(MoveResponse{
			Success: false,
			Error:   "Session not found",
		})
		return
	}

	legalMoves := g.GenerateLegalMoves()
	move, err := game.ParseMove(req.Move, legalMoves)
	if err != nil {
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(MoveResponse{
			Success: false,
			Error:   err.Error(),
			State:   getGameState(g, "illegal"),
		})
		return
	}

	result := g.MakeMove(move)

	// Determine sound type based on move result
	soundType := ""
	if result.WasCheckmate {
		soundType = "checkmate"
	} else if result.WasCheck {
		soundType = "check"
	} else if result.WasCastle {
		soundType = "castle"
	} else if result.WasPromotion {
		soundType = "promote"
	} else if result.WasCapture {
		soundType = "capture"
	} else {
		soundType = "move"
	}

	mu.Lock()
	sessionTimes[req.SessionID] = time.Now()
	mu.Unlock()

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(MoveResponse{
		Success: true,
		State:   getGameState(g, soundType),
	})
}

func handleUndoMove(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	var req struct {
		SessionID string `json:"sessionId"`
	}
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "Invalid request", http.StatusBadRequest)
		return
	}

	mu.RLock()
	g, exists := sessions[req.SessionID]
	mu.RUnlock()

	if !exists {
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(MoveResponse{
			Success: false,
			Error:   "Session not found",
		})
		return
	}

	g.UndoMove()

	mu.Lock()
	sessionTimes[req.SessionID] = time.Now()
	mu.Unlock()

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(MoveResponse{
		Success: true,
		State:   getGameState(g, ""),
	})
}

// New endpoint to get sound URLs
func handleGetSounds(w http.ResponseWriter, r *http.Request) {
	sounds := SoundData{
		Move:      "/move.mp3",
		Capture:   "/capture.mp3",
		Castle:    "/castle.mp3",
		Check:     "/check.mp3",
		Checkmate: "/checkmate.mp3",
		Illegal:   "/illegal.mp3",
		Promote:   "/promote.mp3",
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(sounds)
}

func getGameState(g *game.Game, soundType string) GameStateResponse {
	board := make([]string, 64)
	for i := 0; i < 64; i++ {
		board[i] = g.Board[i].String()
	}

	legalMoves := g.GenerateLegalMoves()
	legalMovesStr := make([]string, len(legalMoves))
	for i, m := range legalMoves {
		legalMovesStr[i] = fmt.Sprintf("%s%s", game.IndexToCoord(m.From), game.IndexToCoord(m.To))
	}

	gameOver := len(legalMoves) == 0
	winner := ""
	isStalemate := false

	if gameOver {
		if g.Board.InCheck(g.Turn) {
			if g.Turn == game.White {
				winner = "Black"
			} else {
				winner = "White"
			}
		} else {
			isStalemate = true
		}
	}

	lastMove := ""
	if len(g.History) > 0 {
		m := g.History[len(g.History)-1]
		lastMove = fmt.Sprintf("%s%s", game.IndexToCoord(m.From), game.IndexToCoord(m.To))
	}

	capturedPieces := getCapturedPieces(g)

	return GameStateResponse{
		Board:          board,
		Turn:           g.Turn.String(),
		InCheck:        g.Board.InCheck(g.Turn),
		LegalMoves:     legalMovesStr,
		GameOver:       gameOver,
		Winner:         winner,
		IsStalemate:    isStalemate,
		LastMove:       lastMove,
		CapturedPieces: capturedPieces,
		SoundType:      soundType,
	}
}

func getCapturedPieces(g *game.Game) []string {
	captured := []string{}

	whitePieces := map[game.PieceType]int{
		game.Pawn: 8, game.Knight: 2, game.Bishop: 2,
		game.Rook: 2, game.Queen: 1, game.King: 1,
	}
	blackPieces := map[game.PieceType]int{
		game.Pawn: 8, game.Knight: 2, game.Bishop: 2,
		game.Rook: 2, game.Queen: 1, game.King: 1,
	}

	for i := 0; i < 64; i++ {
		piece := g.Board[i]
		if piece.Type != game.Empty {
			if piece.Color == game.White {
				whitePieces[piece.Type]--
			} else {
				blackPieces[piece.Type]--
			}
		}
	}

	for pType, count := range whitePieces {
		for i := 0; i < count; i++ {
			captured = append(captured, "w"+string(game.Piece{Type: pType, Color: game.White}.String()))
		}
	}
	for pType, count := range blackPieces {
		for i := 0; i < count; i++ {
			captured = append(captured, "b"+string(game.Piece{Type: pType, Color: game.Black}.String()))
		}
	}

	return captured
}

func generateSessionID() string {
	return fmt.Sprintf("session_%d_%d", len(sessions)+1, time.Now().UnixNano())
}

func cleanupSessions() {
	for {
		time.Sleep(1 * time.Hour)
		mu.Lock()
		now := time.Now()
		for id, lastActive := range sessionTimes {
			if now.Sub(lastActive) > 24*time.Hour {
				delete(sessions, id)
				delete(sessionTimes, id)
			}
		}
		mu.Unlock()
	}
}



File: ./internal/server/assets/index.html
----------------
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess - Monochrome Glass</title>
    <style>
        :root {
            --bg-dark: #000000;
            --bg-light: #1a1a1a;
            --glass-surface: rgba(255, 255, 255, 0.03);
            --glass-border: rgba(255, 255, 255, 0.1);
            --glass-highlight: rgba(255, 255, 255, 0.08);
            --text-main: #ffffff;
            --text-muted: #888888;
            
            --sq-light: rgba(255, 255, 255, 0.1);
            --sq-dark: rgba(0, 0, 0, 0.3);
            --sq-hover: rgba(255, 255, 255, 0.2);
            --sq-selected: rgba(255, 255, 255, 0.25);
            --sq-last-move: rgba(255, 255, 255, 0.15);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', 'Segoe UI', sans-serif;
            background: radial-gradient(circle at 50% 50%, #2a2a2a 0%, #000000 120%);
            min-height: 100vh;
            color: var(--text-main);
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden; /* Prevent scroll on full screen apps */
        }

        .container {
            display: flex;
            gap: 40px;
            max-width: 1400px;
            width: 95%;
            height: 90vh;
            align-items: center;
            justify-content: center;
        }

        /* --- Glassmorphism Panels --- */
        .glass-panel {
            background: var(--glass-surface);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            border-radius: 24px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }

        .game-area {
            padding: 40px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .sidebar {
            padding: 30px;
            min-width: 350px;
            max-width: 400px;
            height: 100%;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        /* --- Chess Board --- */
        .board {
            display: grid;
            grid-template-columns: repeat(8, 75px);
            grid-template-rows: repeat(8, 75px);
            border: 1px solid var(--glass-border);
            border-radius: 4px;
            overflow: hidden;
            box-shadow: 0 10px 40px rgba(0,0,0,0.6);
        }

        .square {
            width: 75px;
            height: 75px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 52px;
            cursor: pointer;
            position: relative;
            transition: background-color 0.2s ease;
            user-select: none;
        }

        .square.light { background-color: var(--sq-light); }
        .square.dark { background-color: var(--sq-dark); }

        .square:hover {
            background-color: var(--sq-hover);
        }

        .square.selected {
            background-color: var(--sq-selected) !important;
            box-shadow: inset 0 0 15px rgba(255,255,255,0.1);
        }

        .square.last-move {
            background-color: var(--sq-last-move) !important;
        }

        /* --- Pieces Styling --- */
        /* White pieces: Pure white with a subtle shadow */
        .piece-white {
            color: #ffffff;
            text-shadow: 0 4px 10px rgba(0,0,0,0.5);
            filter: drop-shadow(0 0 2px rgba(0,0,0,0.8));
        }

        /* Black pieces: Dark grey with a white outline/glow to be visible on black */
        .piece-black {
            color: #1a1a1a;
            text-shadow: 0 0 2px rgba(255,255,255,0.4); 
        }

        /* --- Legal Move Indicators --- */
        .square.legal-move::after {
            content: '';
            position: absolute;
            width: 14px;
            height: 14px;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            pointer-events: none;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
        }

        .square.legal-move:hover::after {
            background-color: rgba(255, 255, 255, 0.5);
        }

        .square.legal-move.has-piece::after {
            width: 100%;
            height: 100%;
            border-radius: 0;
            background: none;
            box-shadow: inset 0 0 0 4px rgba(255, 255, 255, 0.2);
        }

        /* --- Typography & UI Elements --- */
        h2, h3 {
            font-weight: 300;
            letter-spacing: 1px;
            text-transform: uppercase;
            font-size: 14px;
            color: var(--text-muted);
            margin-bottom: 10px;
            border-bottom: 1px solid var(--glass-border);
            padding-bottom: 5px;
        }

        .status-header {
            font-size: 24px;
            font-weight: 600;
            margin-bottom: 20px;
            letter-spacing: -0.5px;
            color: var(--text-main);
        }

        .turn-indicator {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 15px;
            background: rgba(255,255,255,0.02);
            border-radius: 12px;
            border: 1px solid var(--glass-border);
        }

        .turn-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }
        .turn-dot.white { background: #fff; box-shadow: 0 0 10px rgba(255,255,255,0.5); }
        .turn-dot.black { background: #000; border: 1px solid #555; }

        /* --- Alerts (Check/Mate) --- */
        .alert {
            margin-top: 15px;
            padding: 12px;
            border-radius: 8px;
            font-weight: 600;
            text-align: center;
            font-size: 14px;
            letter-spacing: 1px;
            border: 1px solid currentColor;
            background: rgba(0,0,0,0.3);
        }
        .alert.check { color: #ffffff; border-color: #ffffff; }
        .alert.checkmate { color: #ffffff; background: #ffffff; color: #000; }
        .alert.stalemate { color: #aaaaaa; border-color: #aaaaaa; }

        /* --- Captured Pieces --- */
        .captured-list {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            min-height: 30px;
            margin-bottom: 20px;
        }
        .captured-piece {
            font-size: 20px;
            opacity: 0.6;
            color: var(--text-main);
        }

        /* --- Sound Toggle --- */
        .sound-toggle-container {
            margin-top: auto;
            margin-bottom: 10px;
        }
        
        .sound-toggle {
            display: flex;
            align-items: center;
            gap: 10px;
            color: var(--text-muted);
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            transition: color 0.2s;
        }
        .sound-toggle:hover { color: var(--text-main); }
        .sound-toggle input { accent-color: #fff; cursor: pointer; }

        /* --- Buttons --- */
        .controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        button {
            padding: 15px;
            background: transparent;
            border: 1px solid var(--glass-border);
            color: var(--text-main);
            font-family: inherit;
            font-weight: 500;
            text-transform: uppercase;
            font-size: 12px;
            letter-spacing: 1px;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.2s;
        }

        button:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.3);
        }

        button.btn-primary {
            background: rgba(255, 255, 255, 0.9);
            color: black;
            border: none;
        }
        button.btn-primary:hover {
            background: #ffffff;
            box-shadow: 0 0 15px rgba(255,255,255,0.3);
        }

        /* --- History --- */
        .history-list {
            flex: 1;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 12px;
            padding: 10px;
            border: 1px solid var(--glass-border);
            font-family: 'Roboto Mono', monospace;
            font-size: 13px;
        }
        
        .move-row {
            display: flex;
            justify-content: space-between;
            padding: 4px 8px;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }
        .move-row:last-child { border-bottom: none; }
        .move-num { color: var(--text-muted); width: 30px; }
        .move-white { color: var(--text-main); }
        .move-black { color: var(--text-muted); }

        /* --- Scrollbar --- */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 3px; }

        /* --- Promotion Dialog --- */
        .overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
            z-index: 999;
            display: none;
            opacity: 0;
            transition: opacity 0.3s;
        }
        .overlay.active { display: block; opacity: 1; }

        .promotion-dialog {
            position: fixed;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            background: #111;
            border: 1px solid #333;
            padding: 30px;
            border-radius: 20px;
            z-index: 1000;
            display: none;
            transition: transform 0.3s;
            box-shadow: 0 20px 60px rgba(0,0,0,0.8);
            text-align: center;
        }
        .promotion-dialog.active { display: block; transform: translate(-50%, -50%) scale(1); }

        .promotion-pieces {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }
        .promotion-piece {
            width: 70px; height: 70px;
            display: flex; align-items: center; justify-content: center;
            font-size: 40px;
            background: #222;
            border-radius: 12px;
            cursor: pointer;
            border: 1px solid #333;
            color: #fff;
            transition: all 0.2s;
        }
        .promotion-piece:hover { background: #333; border-color: #fff; }

        @media (max-width: 1000px) {
            .container { flex-direction: column; height: auto; padding: 20px; }
            .sidebar { width: 100%; max-width: none; }
            .board { grid-template-columns: repeat(8, 1fr); grid-template-rows: repeat(8, 1fr); width: 100vw; max-width: 90vw; height: 90vw; max-height: 90vw; }
            .square { width: auto; height: auto; font-size: 8vw; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="glass-panel game-area">
            <div class="board" id="board"></div>
        </div>

        <div class="glass-panel sidebar">
            <div>
                <div class="status-header">Chess</div>
                <div class="turn-indicator">
                    <div class="turn-dot white" id="turnDot"></div>
                    <span id="turnText">White's Turn</span>
                </div>
                <div id="alerts"></div>
            </div>

            <div>
                <h3>Captured</h3>
                <div class="captured-list" id="capturedList"></div>
            </div>

            <div class="history-list" id="historyList">
                <div style="color:#555; text-align:center; padding-top:20px;">History logs...</div>
            </div>

            <div class="sound-toggle-container">
                <label class="sound-toggle">
                    <input type="checkbox" id="soundToggle" checked onchange="toggleSound()">
                    <span>Enable Sounds</span>
                </label>
            </div>

            <div class="controls">
                <button class="btn-secondary" onclick="undoMove()">Undo</button>
                <button class="btn-primary" onclick="newGame()">New Game</button>
            </div>
        </div>
    </div>

    <div class="overlay" id="overlay"></div>
    <div class="promotion-dialog" id="promotionDialog">
        <h3>Promote Pawn</h3>
        <div class="promotion-pieces" id="promotionPieces"></div>
    </div>

    <script>
        let sessionId = null;
        let gameState = null;
        let selectedSquare = null;
        let pendingPromotion = null;
        
        // --- Audio Logic ---
        let sounds = {};
        let soundEnabled = true;
        
        // Browser Autoplay Policy: We must track if user has interacted with page
        let userInteracted = false;
        document.addEventListener('click', () => {
            userInteracted = true;
        }, { capture: true, once: true });

        const pieceUnicode = {
            'P': '♙', 'N': '♘', 'B': '♗', 'R': '♖', 'Q': '♕', 'K': '♔',
            'p': '♟', 'n': '♞', 'b': '♝', 'r': '♜', 'q': '♛', 'k': '♚',
            '.': ''
        };

        // --- Sound Functions ---
        async function loadSounds() {
            const soundFiles = ['move', 'capture', 'castle', 'check', 'checkmate', 'illegal', 'promote'];
            
            for (const sound of soundFiles) {
                sounds[sound] = new Audio(`/${sound}.mp3`);
                sounds[sound].preload = 'auto'; // Ensure it's ready
                sounds[sound].onerror = () => {
                    console.warn(`Could not load sound: ${sound}.mp3`);
                };
            }
        }

        function playSound(soundType) {
            if (!soundEnabled || !sounds[soundType]) return;
            if (!userInteracted) {
                // Silently return if user hasn't interacted (prevents console warnings)
                return;
            }
            
            try {
                // Use cloneNode() to create a fresh audio instance.
                // This allows overlapping sounds (rapid moves) and prevents
                // the "play() request was interrupted" error.
                const audioClone = sounds[soundType].cloneNode();
                
                const playPromise = audioClone.play();
                if (playPromise !== undefined) {
                    playPromise.catch(error => {
                        console.warn(`Audio playback blocked:`, error);
                    });
                }
            } catch (e) {
                console.warn(`Error playing sound ${soundType}:`, e);
            }
        }

        function toggleSound() {
            soundEnabled = document.getElementById('soundToggle').checked;
            if (soundEnabled && userInteracted) {
                playSound('move'); // Feedback sound
            }
        }

        // Added 'silent' parameter to prevent error on initial page load
        async function newGame(silent = false) {
            try {
                const response = await fetch('/api/new-game', { method: 'POST' });
                const data = await response.json();
                sessionId = data.sessionId;
                gameState = data.state;
                renderGame();
                if (!silent) {
                    playSound('move'); // Play start sound only if requested
                }
            } catch (error) { console.error(error); }
        }

        async function makeMove(from, to, promotion = '') {
            try {
                // --- Optimistic Sound Prediction ---
                let predictedSound = 'move';
                
                const pieceAtTarget = gameState.board[to];
                const movingPiece = gameState.board[from];
                const isCapture = pieceAtTarget !== '.';
                const isKing = movingPiece.toLowerCase() === 'k';
                const moveDist = Math.abs(from - to);
                
                if (promotion) {
                    predictedSound = 'promote';
                } else if (isKing && moveDist === 2) {
                    predictedSound = 'castle';
                } else if (isCapture) {
                    predictedSound = 'capture';
                }
                
                // Play predicted sound IMMEDIATELY (Zero Delay)
                playSound(predictedSound);

                // --- Send Request ---
                const move = indexToCoord(from) + indexToCoord(to) + promotion;
                const response = await fetch('/api/make-move', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ sessionId, move })
                });
                const data = await response.json();
                
                if (data.success) {
                    gameState = data.state;
                    selectedSquare = null;
                    renderGame();

                    // --- Server Sound Correction ---
                    const serverSound = data.state.soundType;
                    if (serverSound === 'check' || serverSound === 'checkmate') {
                        playSound(serverSound);
                    } else if (serverSound === 'capture' && predictedSound !== 'capture') {
                        playSound('capture'); 
                    }
                } else {
                    playSound('illegal'); // Play error sound (cancel feedback)
                    console.log('Invalid move: ' + data.error);
                }
            } catch (error) { console.error(error); }
        }

        async function undoMove() {
             try {
                const response = await fetch('/api/undo-move', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ sessionId })
                });
                const data = await response.json();
                if (data.success) {
                    gameState = data.state;
                    selectedSquare = null;
                    renderGame();
                    playSound('move'); // Sound for undo
                }
            } catch (error) { console.error(error); }
        }

        function renderGame() {
            if (!gameState) return;
            renderBoard();
            renderStatus();
            renderCapturedPieces();
            renderHistory();
        }

        function renderBoard() {
            const board = document.getElementById('board');
            board.innerHTML = '';

            for (let rank = 7; rank >= 0; rank--) {
                for (let file = 0; file < 8; file++) {
                    const index = rank * 8 + file;
                    const square = document.createElement('div');
                    square.className = 'square';
                    square.className += (rank + file) % 2 === 0 ? ' light' : ' dark';
                    
                    const piece = gameState.board[index];
                    square.textContent = pieceUnicode[piece] || '';

                    // Add Specific Class for White/Black pieces to control contrast
                    if (piece !== '.') {
                        square.classList.add('has-piece');
                        if (piece === piece.toUpperCase()) {
                            square.classList.add('piece-white');
                        } else {
                            square.classList.add('piece-black');
                        }
                    }

                    // Selection & Highlights
                    if (selectedSquare === index) square.classList.add('selected');

                    if (gameState.lastMove) {
                        const from = coordToIndex(gameState.lastMove.substring(0, 2));
                        const to = coordToIndex(gameState.lastMove.substring(2, 4));
                        if (index === from || index === to) square.classList.add('last-move');
                    }

                    // Legal Moves
                    if (selectedSquare !== null) {
                        const moveStr = indexToCoord(selectedSquare) + indexToCoord(index);
                        if (gameState.legalMoves.some(m => m.startsWith(moveStr))) {
                            square.classList.add('legal-move');
                        }
                    }

                    square.onclick = () => handleSquareClick(index);
                    board.appendChild(square);
                }
            }
        }

        function handleSquareClick(index) {
            if (gameState.gameOver) return;

            const piece = gameState.board[index];
            const isOwnPiece = (gameState.turn === 'White' && piece === piece.toUpperCase() && piece !== '.') ||
                               (gameState.turn === 'Black' && piece === piece.toLowerCase() && piece !== '.');

            if (selectedSquare === null) {
                if (isOwnPiece) {
                    selectedSquare = index;
                    renderBoard();
                }
            } else {
                const moveStr = indexToCoord(selectedSquare) + indexToCoord(index);
                const possibleMoves = gameState.legalMoves.filter(m => m.startsWith(moveStr));

                // Standard Move
                if (possibleMoves.length > 0) {
                    if (possibleMoves.length === 1) {
                        makeMove(selectedSquare, index);
                    } else {
                        // Promotion
                        pendingPromotion = { from: selectedSquare, to: index };
                        showPromotionDialog();
                    }
                } 
                // Special Castling (Click King then Rook)
                else if (isOwnPiece && piece.toLowerCase() === 'r') {
                     makeMove(selectedSquare, index);
                }
                // Switch Selection
                else if (isOwnPiece) {
                    selectedSquare = index; 
                    renderBoard();
                } else {
                    selectedSquare = null; // Deselect
                    renderBoard();
                }
            }
        }

        function showPromotionDialog() {
            const dialog = document.getElementById('promotionDialog');
            const overlay = document.getElementById('overlay');
            const pieces = document.getElementById('promotionPieces');
            
            pieces.innerHTML = '';
            const promotionPieces = gameState.turn === 'White' ? 
                ['Q', 'R', 'B', 'N'] : ['q', 'r', 'b', 'n'];
            const promotionLetters = ['q', 'r', 'b', 'n'];

            promotionPieces.forEach((piece, i) => {
                const div = document.createElement('div');
                div.className = 'promotion-piece';
                div.textContent = pieceUnicode[piece];
                div.onclick = () => {
                    makeMove(pendingPromotion.from, pendingPromotion.to, promotionLetters[i]);
                    hidePromotionDialog();
                };
                pieces.appendChild(div);
            });

            dialog.classList.add('active');
            overlay.classList.add('active');
        }

        function hidePromotionDialog() {
            document.getElementById('promotionDialog').classList.remove('active');
            document.getElementById('overlay').classList.remove('active');
            pendingPromotion = null;
        }

        function renderStatus() {
            const turnText = document.getElementById('turnText');
            const turnDot = document.getElementById('turnDot');
            const alerts = document.getElementById('alerts');

            turnText.textContent = gameState.turn + "'s Turn";
            turnDot.className = 'turn-dot ' + gameState.turn.toLowerCase();

            alerts.innerHTML = '';
            if (gameState.gameOver) {
                const alert = document.createElement('div');
                if (gameState.isStalemate) {
                    alert.className = 'alert stalemate';
                    alert.textContent = 'STALEMATE';
                } else {
                    alert.className = 'alert checkmate';
                    alert.textContent = 'CHECKMATE - ' + gameState.winner.toUpperCase() + ' WINS';
                }
                alerts.appendChild(alert);
            } else if (gameState.inCheck) {
                const alert = document.createElement('div');
                alert.className = 'alert check';
                alert.textContent = 'CHECK';
                alerts.appendChild(alert);
            }
        }

        function renderCapturedPieces() {
            const list = document.getElementById('capturedList');
            list.innerHTML = '';
            gameState.capturedPieces.forEach(piece => {
                const span = document.createElement('span');
                span.className = 'captured-piece';
                span.textContent = pieceUnicode[piece.substring(1)];
                list.appendChild(span);
            });
        }

        function renderHistory() {
            // History placeholder
        }

        function indexToCoord(index) {
            const file = String.fromCharCode(97 + (index % 8));
            const rank = Math.floor(index / 8) + 1;
            return file + rank;
        }

        function coordToIndex(coord) {
            const file = coord.charCodeAt(0) - 97;
            const rank = parseInt(coord[1]) - 1;
            return rank * 8 + file;
        }

        // Initialize sounds and game
        loadSounds();
        newGame(true); // START SILENTLY to avoid browser errors!
    </script>
</body>
</html>


File: ./go.mod
----------------
module github.com/Waleed-Ahmad-dev/Chess-app

go 1.25.6



