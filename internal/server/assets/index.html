<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess - Multiplayer</title>
    <style>
        :root {
            --bg-dark: #000000;
            --bg-light: #1a1a1a;
            --glass-surface: rgba(255, 255, 255, 0.03);
            --glass-border: rgba(255, 255, 255, 0.1);
            --text-main: #ffffff;
            --text-muted: #888888;
            --sq-light: rgba(255, 255, 255, 0.1);
            --sq-dark: rgba(0, 0, 0, 0.3);
            --sq-hover: rgba(255, 255, 255, 0.2);
            --sq-selected: rgba(255, 255, 255, 0.25);
            --sq-last-move: rgba(255, 255, 255, 0.15);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Inter', 'Segoe UI', sans-serif;
            background: radial-gradient(circle at 50% 50%, #2a2a2a 0%, #000000 120%);
            min-height: 100vh;
            color: var(--text-main);
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        .container {
            display: flex;
            gap: 40px;
            max-width: 1400px;
            width: 95%;
            height: 90vh;
            align-items: center;
            justify-content: center;
        }

        .glass-panel {
            background: var(--glass-surface);
            backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            border-radius: 24px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }

        .game-area { padding: 40px; display: flex; justify-content: center; align-items: center; }
        .sidebar {
            padding: 30px;
            min-width: 350px;
            max-width: 400px;
            height: 100%;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .board {
            display: grid;
            grid-template-columns: repeat(8, 75px);
            grid-template-rows: repeat(8, 75px);
            border: 1px solid var(--glass-border);
            border-radius: 4px;
            overflow: hidden;
            box-shadow: 0 10px 40px rgba(0,0,0,0.6);
        }

        .square {
            width: 75px; height: 75px;
            display: flex; align-items: center; justify-content: center;
            font-size: 52px; cursor: pointer;
            position: relative;
            user-select: none;
        }
        .square.light { background-color: var(--sq-light); }
        .square.dark { background-color: var(--sq-dark); }
        .square:hover { background-color: var(--sq-hover); }
        .square.selected { background-color: var(--sq-selected) !important; }
        .square.last-move { background-color: var(--sq-last-move) !important; }
        
        .square.legal-move::after {
            content: ''; position: absolute; width: 14px; height: 14px;
            background-color: rgba(255, 255, 255, 0.2); border-radius: 50%; pointer-events: none;
        }
        .square.legal-move:hover::after { background-color: rgba(255, 255, 255, 0.5); }
        .square.legal-move.has-piece::after {
            width: 100%; height: 100%; border-radius: 0; background: none;
            box-shadow: inset 0 0 0 4px rgba(255, 255, 255, 0.2);
        }

        .piece-white { color: #ffffff; text-shadow: 0 4px 10px rgba(0,0,0,0.5); }
        .piece-black { color: #1a1a1a; text-shadow: 0 0 2px rgba(255,255,255,0.4); }

        h2, h3 { color: var(--text-muted); font-size: 14px; text-transform: uppercase; margin-bottom: 10px; border-bottom: 1px solid var(--glass-border); padding-bottom: 5px; }
        
        .status-header { font-size: 24px; font-weight: 600; margin-bottom: 10px; color: var(--text-main); }
        .room-display { font-size: 14px; color: var(--text-muted); margin-bottom: 15px; background: rgba(255,255,255,0.05); padding: 5px 10px; border-radius: 6px; display: inline-block; font-family: monospace; letter-spacing: 1px; }

        .turn-indicator {
            display: flex; align-items: center; gap: 12px; padding: 15px;
            background: rgba(255,255,255,0.02); border-radius: 12px; border: 1px solid var(--glass-border);
        }
        .turn-dot { width: 12px; height: 12px; border-radius: 50%; }
        .turn-dot.white { background: #fff; box-shadow: 0 0 10px rgba(255,255,255,0.5); }
        .turn-dot.black { background: #000; border: 1px solid #555; }

        .captured-list { display: flex; flex-wrap: wrap; gap: 5px; min-height: 30px; margin-bottom: 20px; }
        .captured-piece { font-size: 20px; opacity: 0.6; color: var(--text-main); }

        .controls { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: auto; }
        button {
            padding: 15px; background: transparent; border: 1px solid var(--glass-border);
            color: var(--text-main); text-transform: uppercase; font-size: 12px;
            cursor: pointer; border-radius: 8px; transition: all 0.2s;
        }
        button:hover { background: rgba(255, 255, 255, 0.1); }
        button.btn-primary { background: rgba(255, 255, 255, 0.9); color: black; border: none; }
        button.btn-primary:hover { background: #ffffff; box-shadow: 0 0 15px rgba(255,255,255,0.3); }

        /* Inputs */
        input[type="text"] {
            background: rgba(0,0,0,0.5); border: 1px solid #555; color: white;
            padding: 10px; border-radius: 8px; width: 100%; text-align: center;
            font-size: 16px; letter-spacing: 2px; text-transform: uppercase;
            margin-bottom: 15px;
        }

        /* Modals */
        .overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 999; display: none; }
        .overlay.active { display: block; }
        .modal {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: #111; border: 1px solid #333; padding: 30px;
            border-radius: 20px; z-index: 1000; display: none; text-align: center;
            width: 300px;
        }
        .modal.active { display: block; }

        .promotion-pieces { display: flex; gap: 20px; justify-content: center; margin-top: 20px; }
        .promotion-piece {
            width: 60px; height: 60px; font-size: 35px; background: #222;
            border: 1px solid #333; border-radius: 12px; cursor: pointer;
            display: flex; align-items: center; justify-content: center;
        }
        .promotion-piece:hover { background: #333; border-color: #fff; }

        .menu-options { display: flex; flex-direction: column; gap: 15px; }

        @media (max-width: 1000px) {
            .container { flex-direction: column; height: auto; padding: 20px; }
            .sidebar { width: 100%; max-width: none; }
            .board { grid-template-columns: repeat(8, 1fr); grid-template-rows: repeat(8, 1fr); width: 90vw; height: 90vw; }
            .square { width: auto; height: auto; font-size: 8vw; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="glass-panel game-area">
            <div class="board" id="board"></div>
        </div>

        <div class="glass-panel sidebar">
            <div>
                <div class="status-header">Chess</div>
                <div class="room-display" id="roomDisplay">Not Connected</div>
                <div class="turn-indicator">
                    <div class="turn-dot white" id="turnDot"></div>
                    <span id="turnText">Waiting...</span>
                </div>
            </div>

            <div>
                <h3>Captured</h3>
                <div class="captured-list" id="capturedList"></div>
            </div>

            <div class="controls">
                <button onclick="undoMove()">Undo</button>
                <button class="btn-primary" onclick="showStartScreen()">Menu</button>
            </div>
            
            <div style="margin-top: 10px; font-size: 12px; color: #555; text-align: center;">
                <label><input type="checkbox" id="soundToggle" checked> Sounds</label>
                <label style="margin-left: 10px;"><input type="checkbox" id="autoFlipToggle" checked onchange="renderBoard()"> Auto-Flip</label>
            </div>
        </div>
    </div>

    <div class="overlay" id="overlay"></div>

    <div class="modal" id="promotionDialog">
        <h3>Promote</h3>
        <div class="promotion-pieces" id="promotionPieces"></div>
    </div>

    <div class="modal" id="startDialog">
        <h3 style="margin-bottom: 20px; color: white;">Chess</h3>
        <div class="menu-options">
            <button class="btn-primary" onclick="createRoom('online')">Create Online Room</button>
            <button onclick="createRoom('local')">Pass & Play</button>
            <div style="border-top: 1px solid #333; margin: 5px 0;"></div>
            <input type="text" id="joinCodeInput" placeholder="ROOM CODE" maxlength="4">
            <button onclick="joinRoom()">Join Room</button>
        </div>
    </div>

    <script>
        let roomId = null;
        let gameState = null;
        let selectedSquare = null;
        let pendingPromotion = null;
        let socket = null;
        let playerSide = null; // 'White' or 'Black'
        let gameMode = 'online'; // 'online' or 'local'

        const pieceUnicode = {
            'P': '♙', 'N': '♘', 'B': '♗', 'R': '♖', 'Q': '♕', 'K': '♔',
            'p': '♟', 'n': '♞', 'b': '♝', 'r': '♜', 'q': '♛', 'k': '♚', '.': ''
        };

        let sounds = {};
        async function loadSounds() {
            const files = ['move', 'capture', 'castle', 'check', 'checkmate', 'illegal', 'promote'];
            for (const f of files) {
                sounds[f] = new Audio(`/${f}.mp3`);
                sounds[f].preload = 'auto';
            }
        }
        function playSound(type) {
            if (document.getElementById('soundToggle').checked && sounds[type]) {
                sounds[type].cloneNode().play().catch(() => {});
            }
        }

        // --- WebSocket ---
        function connectWebSocket(rid) {
            if (socket) socket.close();
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            socket = new WebSocket(`${protocol}//${window.location.host}/ws?room=${rid}`);

            socket.onopen = () => console.log("Connected to Room " + rid);
            
            socket.onmessage = (event) => {
                const data = JSON.parse(event.data);
                
                // Handle Initial Handshake
                if (data.type === 'init') {
                    playerSide = data.color;
                    roomId = data.roomId;
                    gameState = data.state;
                    gameMode = data.mode; // 'local' or 'online'
                    
                    let display = `Room: ${roomId}`;
                    if (gameMode === 'local') {
                        display += ` | Pass & Play`;
                    } else {
                        display += ` | You: ${playerSide}`;
                    }
                    document.getElementById('roomDisplay').textContent = display;
                    renderGame();
                } else {
                    // Standard Update
                    gameState = data;
                    selectedSquare = null;
                    renderGame();
                    if (data.soundType) playSound(data.soundType);
                }
            };
            
            socket.onerror = (e) => console.log("WS Error", e);
        }

        // --- API Calls ---
        async function createRoom(mode) {
            try {
                const res = await fetch('/api/create-room', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ mode: mode })
                });
                const data = await res.json();
                roomId = data.roomId;
                gameState = data.state;
                gameMode = mode;
                
                closeModal();
                connectWebSocket(roomId);
            } catch (e) { console.error(e); }
        }

        function joinRoom() {
            const code = document.getElementById('joinCodeInput').value.toUpperCase();
            if (code.length !== 4) return alert("Enter a 4-letter code");
            roomId = code;
            closeModal();
            connectWebSocket(code);
        }

        async function makeMove(from, to, promotion = '') {
            // Client-side turn check
            // If Local: allow move if game not over.
            // If Online: allow move only if game not over AND it is my turn.
            if (gameState.gameOver) return;
            if (gameMode === 'online' && gameState.turn !== playerSide) return;

            const move = indexToCoord(from) + indexToCoord(to) + promotion;
            try {
                const res = await fetch('/api/make-move', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ roomId, move })
                });
                const data = await res.json();
                if (data.success) {
                    // Optimistic update not strictly needed as WS is fast enough locally
                } else {
                    playSound('illegal');
                }
            } catch (e) { console.error(e); }
        }

        async function undoMove() {
            await fetch('/api/undo-move', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ roomId })
            });
        }

        // --- Rendering ---
        function renderGame() {
            if (!gameState) return;
            renderBoard();
            
            // Status
            document.getElementById('turnText').textContent = gameState.turn + "'s Turn";
            document.getElementById('turnDot').className = 'turn-dot ' + gameState.turn.toLowerCase();

            // Captured
            const list = document.getElementById('capturedList');
            list.innerHTML = '';
            gameState.capturedPieces.forEach(p => {
                const s = document.createElement('span');
                s.className = 'captured-piece';
                s.textContent = pieceUnicode[p.substring(1)];
                list.appendChild(s);
            });
        }

        function renderBoard() {
            const board = document.getElementById('board');
            board.innerHTML = '';
            
            // Auto-flip Logic:
            // Local Mode: Flip if Turn is Black (Hotseat style)
            // Online Mode: Flip if I am Black
            const autoFlip = document.getElementById('autoFlipToggle').checked;
            let isFlipped = false;
            
            if (autoFlip) {
                if (gameMode === 'local') {
                    isFlipped = (gameState.turn === 'Black');
                } else {
                    isFlipped = (playerSide === 'Black');
                }
            }

            for (let rank = isFlipped ? 0 : 7; isFlipped ? rank < 8 : rank >= 0; isFlipped ? rank++ : rank--) {
                for (let file = isFlipped ? 7 : 0; isFlipped ? file >= 0 : file < 8; isFlipped ? file-- : file++) {
                    const idx = rank * 8 + file;
                    const sq = document.createElement('div');
                    sq.className = 'square ' + ((rank + file) % 2 !== 0 ? 'light' : 'dark');
                    
                    const piece = gameState.board[idx];
                    sq.textContent = pieceUnicode[piece];
                    
                    if (piece !== '.') {
                        sq.classList.add('has-piece');
                        sq.classList.add(piece === piece.toUpperCase() ? 'piece-white' : 'piece-black');
                    }

                    if (selectedSquare === idx) sq.classList.add('selected');
                    
                    // Legal Moves Highlighting
                    if (selectedSquare !== null) {
                        const mStr = indexToCoord(selectedSquare) + indexToCoord(idx);
                        if (gameState.legalMoves.some(m => m.startsWith(mStr))) sq.classList.add('legal-move');
                    }

                    sq.onclick = () => handleSquareClick(idx);
                    board.appendChild(sq);
                }
            }
        }

        function handleSquareClick(idx) {
            if (gameState.gameOver) return;
            
            // Interaction Check:
            // Online: Must be my turn.
            // Local: Must be valid turn (always true if game not over).
            if (gameMode === 'online' && playerSide !== gameState.turn) return;

            const piece = gameState.board[idx];
            
            // Determine if the piece clicked belongs to the person whose turn it is
            // White pieces are Uppercase, Black are Lowercase
            const isWhitePiece = (piece === piece.toUpperCase() && piece !== '.');
            const isBlackPiece = (piece === piece.toLowerCase() && piece !== '.');
            
            let isOwnPiece = false;
            if (gameState.turn === 'White' && isWhitePiece) isOwnPiece = true;
            if (gameState.turn === 'Black' && isBlackPiece) isOwnPiece = true;

            if (selectedSquare === null) {
                if (isOwnPiece) { selectedSquare = idx; renderBoard(); }
            } else {
                const moveStr = indexToCoord(selectedSquare) + indexToCoord(idx);
                const candidates = gameState.legalMoves.filter(m => m.startsWith(moveStr));
                
                if (candidates.length === 1) {
                    makeMove(selectedSquare, idx);
                } else if (candidates.length > 1) {
                    pendingPromotion = { from: selectedSquare, to: idx };
                    showPromotion();
                } else {
                    if (isOwnPiece) { selectedSquare = idx; renderBoard(); }
                    else { selectedSquare = null; renderBoard(); }
                }
            }
        }

        // Helpers
        function showStartScreen() { 
            document.getElementById('startDialog').classList.add('active'); 
            document.getElementById('overlay').classList.add('active'); 
        }
        function closeModal() { 
            document.querySelectorAll('.modal').forEach(m => m.classList.remove('active'));
            document.getElementById('overlay').classList.remove('active'); 
        }
        function showPromotion() {
            const d = document.getElementById('promotionDialog');
            const p = document.getElementById('promotionPieces');
            p.innerHTML = '';
            
            // Determine promotion color based on current turn
            const isWhiteTurn = gameState.turn === 'White';
            const opts = isWhiteTurn ? ['Q','R','B','N'] : ['q','r','b','n'];
            
            opts.forEach(char => {
                const div = document.createElement('div');
                div.className = 'promotion-piece';
                div.textContent = pieceUnicode[char];
                div.onclick = () => {
                    makeMove(pendingPromotion.from, pendingPromotion.to, char.toLowerCase());
                    closeModal();
                };
                p.appendChild(div);
            });
            d.classList.add('active');
            document.getElementById('overlay').classList.add('active');
        }

        function indexToCoord(i) { return String.fromCharCode(97 + (i % 8)) + (Math.floor(i / 8) + 1); }

        loadSounds();
        showStartScreen();
    </script>
</body>
</html>